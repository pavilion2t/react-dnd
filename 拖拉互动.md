  # Adding the Drag and Drop Interaction 添加拖放互动

This is the part that actually prompted提示 me to write this tutorial.   
这部分才是我想要写这个教程的原因。  

We are now going to see how easy React DnD makes it to add some drag and drop interaction to your existing components.   
我们现在来看如何简单地通过React DnD来给你的组件添加拖放互动。

This part assumes you are at least somewhat familiar with the concepts presented in the overview, such as the backends, the collecting functions, the types, the items, the drag sources, and the drop targets. If you didn't understand everything, it's fine, but make sure you at least give it a chance before jumping into the coding process.

We're going to start by installing React DnD and the HTML5 backend for it:  
首先要安装React DnD and the HTML5 backend：  

```
npm install --save react-dnd react-dnd-html5-backend
```
In the future, you might want to explore alternative third-party backends, such as the touch backend, but this is out of scope of this tutorial.   
将来，你可能会探索更多的第三方后端，比如触屏之类的，但这个不再本教程范围之内。

The first thing we need to set up in our app is the DragDropContext.   
第一件事就是要在我们的APP里安装DragDropContext。

We need it to specify that we're going to use the HTML5 backend in our app.   
我们需要它来详细说明，我们将要在APP里用HTML5 backend。

Because the **Board** is the top-level component in our app, I'm going to put the DragDropContext on it:   
因为Board是我们APP里面最高级别的组件，我将把DragDropContext放在它上面：

```
import React, { Component } from 'react';
import { DragDropContext } from 'react-dnd';
import HTML5Backend from 'react-dnd-html5-backend';

class Board extends Component {
  /* ... */
}

export default DragDropContext(HTML5Backend)(Board);
```
Next, I'm going to create the constants for the draggable item types.   
接下来，我将要创建可拖放的常量项目类型。
 
We're only going to have a single item type in our game, a KNIGHT. I'm creating a Constants module that exports it:   
在我们这里只要有一个常量KNIGHT，我会创建一个常量模块来输出它：  

```
export const ItemTypes = {
  KNIGHT: 'knight'
};
```

The preparation work is done now. Let's make the Knight draggable!
准备工作已经完成，现在来让Knight可拖放！

The DragSource higher-order component accepts three parameters: type, spec, and collect.  

Our type is the constant we just defined, so now we need to write a drag source specification and a collecting function.   

For the Knight, the drag source specification is going to be ridiculously simple:
```
const knightSource = {
  beginDrag(props) {
    return {};
  }
};
```

This is because there is nothing to describe: there is literally a single draggable object in the whole application!  

If we had a bunch of chess pieces, it might be a good idea to use the props parameter and return something like { pieceId: props.id }. In our case, an empty object will suffice.

Next, we're going to write a collecting function. What props does the Knight need? It will sure need a way to specify the drag source node. It would also be nice to slightly dim the Knight's opacity while it is being dragged. Therefore, it needs to know whether it is currently being dragged.

Here is the collecting function I wrote for it:
```
function collect(connect, monitor) {
  return {
    connectDragSource: connect.dragSource(),
    isDragging: monitor.isDragging()
  }
}
```

Let's take a look at the whole Knight component now, including the DragSource call and the updated render function:  
```
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { ItemTypes } from './Constants';
import { DragSource } from 'react-dnd';

const knightSource = {
  beginDrag(props) {
    return {};
  }
};

function collect(connect, monitor) {
  return {
    connectDragSource: connect.dragSource(),
    isDragging: monitor.isDragging()
  }
}

class Knight extends Component {
  render() {
    const { connectDragSource, isDragging } = this.props;
    return connectDragSource(
      <div style={{
        opacity: isDragging ? 0.5 : 1,
        fontSize: 25,
        fontWeight: 'bold',
        cursor: 'move'
      }}>
        ♘
      </div>
    );
  }
}

Knight.propTypes = {
  connectDragSource: PropTypes.func.isRequired,
  isDragging: PropTypes.bool.isRequired
};

export default DragSource(ItemTypes.KNIGHT, knightSource, collect)(Knight);
```

The Knight is now a drag source, but there are no drop targets to handle the drop yet. We're going to make the Square a drop target now.

This time, we can't avoid passing the position to the Square. After all, how can the Square know where to move the dragged knight if the Square doesn't know its own position? On the other hand, it still feels wrong because the Square as an entity in our application has not changed, and if it used to be simple, why complicate it? When you face this dilemma, it's time to separate the smart and dumb components.

I'm going to introduce a new component called the BoardSquare. It renders the good old Square, but is also aware of its position. In fact, it's encapsulating some of the logic that the renderSquare method inside the Board used to do. React components are often extracted from such render submethods when the time is right.

Here is the BoardSquare I extracted:   
```
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Square from './Square';

export default class BoardSquare extends Component {
  render() {
    const { x, y } = this.props;
    const black = (x + y) % 2 === 1;

    return (
      <Square black={black}>
        {this.props.children}
      </Square>
    );
  }
}

BoardSquare.propTypes = {
  x: PropTypes.number.isRequired,
  y: PropTypes.number.isRequired
};
```

I also changed the Board to use it:  
```
renderSquare(i) {
  const x = i % 8;
  const y = Math.floor(i / 8);
  return (
    <div key={i}
         style={{ width: '12.5%', height: '12.5%' }}>
      <BoardSquare x={x}
                   y={y}>
        {this.renderPiece(x, y)}
      </BoardSquare>
    </div>
  );
}

renderPiece(x, y) {
  const [knightX, knightY] = this.props.knightPosition;
  if (x === knightX && y === knightY) {
    return <Knight />;
  }
}
```

Let's now wrap the BoardSquare with a DropTarget. I'm going to write a drop target specification that only handles the drop event:  
```
const squareTarget = {
  drop(props, monitor) {
    moveKnight(props.x, props.y);
  }
};
```

See? The drop method receives the props of the BoardSquare so it knows where to move the knight when it drops. In a real app, I might also use monitor.getItem() to retrieve the dragged item that the drag source returned from beginDrag, but since we only have a single draggable thing in the whole application, I don't need it.

In my collecting function, I'm going to obtain the function to connect my drop target node, and I'm also going to ask the monitor whether the pointer is currently over the BoardSquare so I can highlight it:  
```
function collect(connect, monitor) {
  return {
    connectDropTarget: connect.dropTarget(),
    isOver: monitor.isOver()
  };
}
```
After changing the render function to connect the drop target and show the highlight overlay, here is what BoardSquare came to be:   
```
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Square from './Square';
import { canMoveKnight, moveKnight } from './Game';
import { ItemTypes } from './Constants';
import { DropTarget } from 'react-dnd';

const squareTarget = {
  drop(props) {
    moveKnight(props.x, props.y);
  }
};

function collect(connect, monitor) {
  return {
    connectDropTarget: connect.dropTarget(),
    isOver: monitor.isOver()
  };
}

class BoardSquare extends Component {
  render() {
    const { x, y, connectDropTarget, isOver } = this.props;
    const black = (x + y) % 2 === 1;

    return connectDropTarget(
      <div style={{
        position: 'relative',
        width: '100%',
        height: '100%'
      }}>
        <Square black={black}>
          {this.props.children}
        </Square>
        {isOver &&
          <div style={{
            position: 'absolute',
            top: 0,
            left: 0,
            height: '100%',
            width: '100%',
            zIndex: 1,
            opacity: 0.5,
            backgroundColor: 'yellow',
          }} />
        }
      </div>
    );
  }
}

BoardSquare.propTypes = {
  x: PropTypes.number.isRequired,
  y: PropTypes.number.isRequired,
  isOver: PropTypes.bool.isRequired
};

export default DropTarget(ItemTypes.KNIGHT, squareTarget, collect)(BoardSquare);
```

